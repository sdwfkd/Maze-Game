using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class EndIndicator : MonoBehaviour {
	public Canvas P2;
	public CharacterController characterController;
	public Text angleText;
	private string text = "Angle: ";

	//Edit this for the endpoint generated by the maze. Make it the center of the end space.
	private Vector3 EndPoint = new Vector3(0, 0, 0);

	private bool onLeft = true;

	// Update is called once per frame
	void Update () {
		// Calculate the EndIndicator's angle of rotation for pointing towards the end
		Vector3 Point1 = characterController.transform.position;
		Vector3 Point2 = P2.transform.position;
		Vector3 Point3 = new Vector3(EndPoint.x, EndPoint.y, EndPoint.z);
		// Calculating the distance between all 3 points, 1 is the player, 2 is the canvas in front of the player, 3 is the end
		float A = Mathf.Sqrt(((Point2.x - Point1.x) * (Point2.x - Point1.x)) + ((Point2.z - Point1.z) * (Point2.z - Point1.z)));
		float B = Mathf.Sqrt(((Point3.x - Point1.x) * (Point3.x - Point1.x)) + ((Point3.z - Point1.z) * (Point3.z - Point1.z)));
		float C = Mathf.Sqrt(((Point2.x - Point3.x) * (Point2.x - Point3.x)) + ((Point2.z - Point3.z) * (Point2.z - Point3.z)));
		// Calculating the angle from in front of the player to the end point using law of cosines:
		// https://www.mathsisfun.com/algebra/trig-cosine-law.html

		// This returns 0-180 only, so we need to calculate if the end is on the right side for inversion
		float angleDegrees = Mathf.Acos(((A * A) + (B * B) - (C * C)) / (2 * A * B));
		angleDegrees *= Mathf.Rad2Deg;

		// Calculate if the end is to the left or right, if right then set onLeft = false;
		if(onLeft){
			onLeft = false;
		}else{
			onLeft = true;
		}

		if(!onLeft){
			angleDegrees *= -1;
		}

		var eulerAngles = this.transform.eulerAngles;
		this.transform.rotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, angleDegrees);

		// Can remove this once done
		angleText.text = text + angleDegrees;
	}
}
