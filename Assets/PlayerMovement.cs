using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class PlayerMovement : MonoBehaviour {
	// Variables
	public float moveSpeed = 2.0F;
	public float mouseSpeed = 4.0F;
	private Vector3 moveDirection = Vector3.zero;
	private Vector3 cameraRotation = Vector3.zero;

	private float yRot = 0.0F;
	private float xRot = 0.0F;

	public Canvas P2;
	public RawImage EndIndicator;

	//Edit this for the endpoint generated by the maze. Make it the center of the end space.
	private Vector3 EndPoint = new Vector3(0,0,0);
	
	// Update is called once per frame
	void Update () {
		CharacterController controller = GetComponent<CharacterController>();

		//Feed moveDirection with input
		moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
		moveDirection = transform.TransformDirection(moveDirection);
		// Multiply it by speed
		moveDirection *= moveSpeed;

		//Get and camera rotation through mouse movement
		yRot += Input.GetAxis("Mouse X");

		if (!(xRot + -Input.GetAxis("Mouse Y") > 90 || xRot + -Input.GetAxis("Mouse Y") < -90)){
			xRot += -Input.GetAxis("Mouse Y");
		}

		// Move the Character
		controller.Move(moveDirection * Time.deltaTime);
		// Do special rotational transform calculations so we cannot rotate our Z
		controller.transform.localEulerAngles = new Vector3(xRot, yRot, transform.localEulerAngles.z);

		// Calculate the EndIndicator's angle of rotation for pointing towards the end
		Vector3 Point1 = controller.transform.position;
		Vector3 Point2 = P2.transform.position;
		Vector3 Point3 = new Vector3(EndPoint.x, EndPoint.y, EndPoint.z);
		// Calculating the distance between all 3 points, 1 is the player, 2 is the canvas in front of the player, 3 is the end
		float A = Mathf.Sqrt(((Point2.x - Point1.x) * (Point2.x - Point1.x)) + ((Point2.z - Point1.z) * (Point2.z - Point1.z)));
		float B = Mathf.Sqrt(((Point3.x - Point1.x) * (Point3.x - Point1.x)) + ((Point3.z - Point1.z) * (Point3.z - Point1.z)));
		float C = Mathf.Sqrt(((Point2.x - Point3.x) * (Point2.x - Point3.x)) + ((Point2.z - Point3.z) * (Point2.z - Point3.z)));

		// Calculating the angle from in front of the player to the end point using law of cosines:
		// https://www.mathsisfun.com/algebra/trig-cosine-law.html
		float angleDegrees = Mathf.Acos(((A * A) + (B * B) + (C * C)) / (2 * A * B));

		// Try to calculate the correct change to the z rotation of the indicator. Haven't found a way to just set rotation
		// I think Rotate() rotates by a specified amount of degrees. When angleDegrees = Mathf.Acos(A) the indicator spun in a singular circle
		Quaternion oldRot = EndIndicator.transform.localRotation;
		Quaternion newRot = Quaternion.Euler(0,0,angleDegrees);
		newRot = oldRot * Quaternion.Inverse(newRot);
		EndIndicator.transform.Rotate(new Vector3(0,0,newRot.z));
			//Rotate(new Vector3(0,0,angleDegrees));
	}
}
